/****************************************************************************
*   Generated by ACUITY 3.8.2
*   Match ovxlib 1.0.3
*
*   Neural Network application project entry file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef __linux__
#include <sys/time.h>
#endif

#define _BASETSD_H

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_pre_process.h"
#include "vnn_post_process.h"
#include "vnn_dncnn.h"
//#include "md5sum.h"

/*********************md5sum*****************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <errno.h>


#undef BIG_ENDIAN_HOST
typedef unsigned int u32;


/****************
 * Rotate a 32 bit integer by n bytes
 */
#if defined(__GNUC__) && defined(__i386__)
static inline u32
rol( u32 x, int n)
{
	__asm__("roll %%cl,%0"
		:"=r" (x)
		:"0" (x),"c" (n));
	return x;
}
#else
#define rol(x,n) ( ((x) << (n)) | ((x) >> (32-(n))) )
#endif


typedef struct {
    u32 A,B,C,D;	  /* chaining variables */
    u32  nblocks;
    unsigned char buf[64];
    int  count;
} MD5_CONTEXT;




static void
md5_init( MD5_CONTEXT *ctx )
{
    ctx->A = 0x67452301;
    ctx->B = 0xefcdab89;
    ctx->C = 0x98badcfe;
    ctx->D = 0x10325476;


    ctx->nblocks = 0;
    ctx->count = 0;
}








/* These are the four functions used in the four steps of the MD5 algorithm
   and defined in the RFC 1321.  The first function is a little bit optimized
   (as found in Colin Plumbs public domain implementation).  */
/* #define FF(b, c, d) ((b & c) | (~b & d)) */
#define FF(b, c, d) (d ^ (b & (c ^ d)))
#define FG(b, c, d) FF (d, b, c)
#define FH(b, c, d) (b ^ c ^ d)
#define FI(b, c, d) (c ^ (b | ~d))




/****************
 * transform n*64 bytes
 */
static void
transform( MD5_CONTEXT *ctx, unsigned char *data )
{
    u32 correct_words[16];
    u32 A = ctx->A;
    u32 B = ctx->B;
    u32 C = ctx->C;
    u32 D = ctx->D;
    u32 *cwp = correct_words;


#ifdef BIG_ENDIAN_HOST
    { int i;
      unsigned char *p2, *p1;
      for (i=0, p1=data, p2=(unsigned char*)correct_words; i < 16; i++, p2 += 4 ) {
	p2[3] = *p1++;
	p2[2] = *p1++;
	p2[1] = *p1++;
	p2[0] = *p1++;
      }
    }
#else
    memcpy( correct_words, data, 64 );
#endif




#define OP(a, b, c, d, s, T)					    \
  do								    \
    {								    \
      a += FF (b, c, d) + (*cwp++) + T; 	    \
      a = rol(a, s);						    \
      a += b;							    \
    }								    \
  while (0)


    /* Before we start, one word about the strange constants.
       They are defined in RFC 1321 as


       T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
     */


    /* Round 1.  */
    OP (A, B, C, D,  7, 0xd76aa478);
    OP (D, A, B, C, 12, 0xe8c7b756);
    OP (C, D, A, B, 17, 0x242070db);
    OP (B, C, D, A, 22, 0xc1bdceee);
    OP (A, B, C, D,  7, 0xf57c0faf);
    OP (D, A, B, C, 12, 0x4787c62a);
    OP (C, D, A, B, 17, 0xa8304613);
    OP (B, C, D, A, 22, 0xfd469501);
    OP (A, B, C, D,  7, 0x698098d8);
    OP (D, A, B, C, 12, 0x8b44f7af);
    OP (C, D, A, B, 17, 0xffff5bb1);
    OP (B, C, D, A, 22, 0x895cd7be);
    OP (A, B, C, D,  7, 0x6b901122);
    OP (D, A, B, C, 12, 0xfd987193);
    OP (C, D, A, B, 17, 0xa679438e);
    OP (B, C, D, A, 22, 0x49b40821);


#undef OP
#define OP(f, a, b, c, d, k, s, T)  \
    do								      \
      { 							      \
	a += f (b, c, d) + correct_words[k] + T;		      \
	a = rol(a, s);						      \
	a += b; 						      \
      } 							      \
    while (0)


    /* Round 2.  */
    OP (FG, A, B, C, D,  1,  5, 0xf61e2562);
    OP (FG, D, A, B, C,  6,  9, 0xc040b340);
    OP (FG, C, D, A, B, 11, 14, 0x265e5a51);
    OP (FG, B, C, D, A,  0, 20, 0xe9b6c7aa);
    OP (FG, A, B, C, D,  5,  5, 0xd62f105d);
    OP (FG, D, A, B, C, 10,  9, 0x02441453);
    OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);
    OP (FG, B, C, D, A,  4, 20, 0xe7d3fbc8);
    OP (FG, A, B, C, D,  9,  5, 0x21e1cde6);
    OP (FG, D, A, B, C, 14,  9, 0xc33707d6);
    OP (FG, C, D, A, B,  3, 14, 0xf4d50d87);
    OP (FG, B, C, D, A,  8, 20, 0x455a14ed);
    OP (FG, A, B, C, D, 13,  5, 0xa9e3e905);
    OP (FG, D, A, B, C,  2,  9, 0xfcefa3f8);
    OP (FG, C, D, A, B,  7, 14, 0x676f02d9);
    OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);


    /* Round 3.  */
    OP (FH, A, B, C, D,  5,  4, 0xfffa3942);
    OP (FH, D, A, B, C,  8, 11, 0x8771f681);
    OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);
    OP (FH, B, C, D, A, 14, 23, 0xfde5380c);
    OP (FH, A, B, C, D,  1,  4, 0xa4beea44);
    OP (FH, D, A, B, C,  4, 11, 0x4bdecfa9);
    OP (FH, C, D, A, B,  7, 16, 0xf6bb4b60);
    OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);
    OP (FH, A, B, C, D, 13,  4, 0x289b7ec6);
    OP (FH, D, A, B, C,  0, 11, 0xeaa127fa);
    OP (FH, C, D, A, B,  3, 16, 0xd4ef3085);
    OP (FH, B, C, D, A,  6, 23, 0x04881d05);
    OP (FH, A, B, C, D,  9,  4, 0xd9d4d039);
    OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);
    OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);
    OP (FH, B, C, D, A,  2, 23, 0xc4ac5665);


    /* Round 4.  */
    OP (FI, A, B, C, D,  0,  6, 0xf4292244);
    OP (FI, D, A, B, C,  7, 10, 0x432aff97);
    OP (FI, C, D, A, B, 14, 15, 0xab9423a7);
    OP (FI, B, C, D, A,  5, 21, 0xfc93a039);
    OP (FI, A, B, C, D, 12,  6, 0x655b59c3);
    OP (FI, D, A, B, C,  3, 10, 0x8f0ccc92);
    OP (FI, C, D, A, B, 10, 15, 0xffeff47d);
    OP (FI, B, C, D, A,  1, 21, 0x85845dd1);
    OP (FI, A, B, C, D,  8,  6, 0x6fa87e4f);
    OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);
    OP (FI, C, D, A, B,  6, 15, 0xa3014314);
    OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);
    OP (FI, A, B, C, D,  4,  6, 0xf7537e82);
    OP (FI, D, A, B, C, 11, 10, 0xbd3af235);
    OP (FI, C, D, A, B,  2, 15, 0x2ad7d2bb);
    OP (FI, B, C, D, A,  9, 21, 0xeb86d391);


    /* Put checksum in context given as argument.  */
    ctx->A += A;
    ctx->B += B;
    ctx->C += C;
    ctx->D += D;
}






/* The routine updates the message-digest context to
 * account for the presence of each of the characters inBuf[0..inLen-1]
 * in the message whose digest is being computed.
 */
static void
md5_write( MD5_CONTEXT *hd, unsigned char *inbuf, size_t inlen)
{
    if ( hd->count == 64 ) { /* flush the buffer */
	transform( hd, hd->buf );
	hd->count = 0;
	hd->nblocks++;
    }
    if ( !inbuf )
	return;
    if ( hd->count ) {
	for ( ; inlen && hd->count < 64; inlen-- )
	    hd->buf[hd->count++] = *inbuf++;
	md5_write( hd, NULL, 0 );
	if ( !inlen )
	    return;
    }


    while ( inlen >= 64 ) {
	transform( hd, inbuf );
	hd->count = 0;
	hd->nblocks++;
	inlen -= 64;
	inbuf += 64;
    }
    for ( ; inlen && hd->count < 64; inlen-- )
	hd->buf[hd->count++] = *inbuf++;
}






/* The routine final terminates the message-digest computation and
 * ends with the desired message digest in mdContext->digest[0...15].
 * The handle is prepared for a new MD5 cycle.
 * Returns 16 bytes representing the digest.
 */


static void
md5_final( MD5_CONTEXT *hd )
{
    u32 t, msb, lsb;
    unsigned char *p;


    md5_write(hd, NULL, 0); /* flush */;


    t = hd->nblocks;
    /* multiply by 64 to make a byte count */
    lsb = t << 6;
    msb = t >> 26;
    /* add the count */
    t = lsb;
    if ( (lsb += hd->count) < t )
	msb++;
    /* multiply by 8 to make a bit count */
    t = lsb;
    lsb <<= 3;
    msb <<= 3;
    msb |= t >> 29;


    if ( hd->count < 56 ) { /* enough room */
	hd->buf[hd->count++] = 0x80; /* pad */
	while ( hd->count < 56 )
	    hd->buf[hd->count++] = 0;  /* pad */
    }
    else { /* need one extra block */
	hd->buf[hd->count++] = 0x80; /* pad character */
	while ( hd->count < 64 )
	    hd->buf[hd->count++] = 0;
	md5_write(hd, NULL, 0);  /* flush */;
	memset(hd->buf, 0, 56 ); /* fill next block with zeroes */
    }
    /* append the 64 bit count */
    hd->buf[56] = lsb	   ;
    hd->buf[57] = lsb >>  8;
    hd->buf[58] = lsb >> 16;
    hd->buf[59] = lsb >> 24;
    hd->buf[60] = msb	   ;
    hd->buf[61] = msb >>  8;
    hd->buf[62] = msb >> 16;
    hd->buf[63] = msb >> 24;
    transform( hd, hd->buf );


    p = hd->buf;
#ifdef BIG_ENDIAN_HOST
#define X(a) do { *p++ = hd-> a      ; *p++ = hd-> a >> 8;      \
                  *p++ = hd-> a >> 16; *p++ = hd-> a >> 24; } while(0)
#else /* little endian */
#define X(a) do { *(u32*)p = hd-> a ; p += 4; } while(0)
#endif
    X(A);
    X(B);
    X(C);
    X(D);
#undef X


}


static MD5_CONTEXT oragin(char *filename)
 {
   assert(sizeof(u32) ==4);
   FILE *fp;
   unsigned char buffer[4096];
   size_t n;
   MD5_CONTEXT ctx;

   fp = fopen(filename,"rb");
   md5_init(&ctx);
   while ((n=fread(buffer,1,sizeof buffer,fp)))
     md5_write(&ctx,buffer,n);
   md5_final(&ctx);
   fclose(fp);

   return ctx;
 }


/*-------------------------------------------
        Macros and Variables
-------------------------------------------*/

/*-------------------------------------------
                  Functions
-------------------------------------------*/

static void vnn_SaveOutputData(vsi_nn_graph_t *graph)
{
    uint32_t i,j;
    char filename[64] = {0}, tmp[8] = {0};
    vsi_nn_tensor_t *tensor;

    for (i = 0; i < graph->output.num; i++)
    {
        tensor = vsi_nn_GetTensor(graph, graph->output.tensors[i]);

        sprintf(filename, "output%u", i);
        for (j = 0; j < tensor->attr.dim_num; j++)
        {
            memset(tmp, 0, sizeof(tmp));
            sprintf(tmp, "_%u", tensor->attr.size[j]);
            strcat(filename, tmp);
        }
        strcat(filename, ".txt");

        vsi_nn_SaveTensorToTextByFp32( graph, tensor, filename, NULL );
    }
}

static void vnn_ReleaseNeuralNetwork
    (
    vsi_nn_graph_t *graph
    )
{
    vnn_ReleaseDncnn( graph, TRUE );
}

static vsi_status vnn_PostProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph
    )
{
    return vnn_PostProcessDncnn( graph );
}

static vsi_status vnn_ProcessGraph
    (
    vsi_nn_graph_t *graph
    )
{
    vsi_status status;
    int32_t i,num,loop;
    char *loop_s,*Num;
    FILE *fp;
    FILE *fp1;
    int j;
    MD5_CONTEXT ctx;
    MD5_CONTEXT cty;

    status = VSI_FAILURE;
    loop = 1; /* default loop time is 1 */
    loop_s = getenv("VNN_LOOP_TIME");
    Num = getenv("VNN_TIME");
    if (Num)
     {
        num = atoi(Num);
     }

    if (loop_s)
    {
        loop = atoi(loop_s);
    }
#ifdef __linux__
    struct timeval  sigStart, sigEnd, verStart, verEnd;
    long int msVal,usVal;
    gettimeofday( &verStart, 0 );
#endif
    /* Verify graph */
    status = vsi_nn_VerifyGraph( graph );
    _CHECK_STATUS( status, final );

#ifdef __linux__
    gettimeofday( &verEnd, 0 );
    msVal = 1000 * (verEnd.tv_sec - verStart.tv_sec) + (verEnd.tv_usec - verStart.tv_usec) / 1000;
    usVal = 1000000 * (verEnd.tv_sec - verStart.tv_sec) + (verEnd.tv_usec - verStart.tv_usec);
    printf("verify time:");
    printf("  %ldms or %ldus\n", msVal, usVal);
#endif

    /* Run graph */

    printf("Start run graph [%d] times...\n", loop);
    fp1 = fopen("error_log.txt","w+");
    fprintf(fp1,"\n\n\n\n  loop begain,There are %d time loops in the case\n\n\n\n\n",loop);
    fclose(fp1);


    cty = oragin("output.txt");

    for (i = 0; i < loop; i++)
    {
#ifdef __linux__
        gettimeofday( &sigStart, 0 );
#endif
        status = vsi_nn_RunGraph(graph);
        if (status != VSI_SUCCESS)
        {
            printf("Run graph the %d time fail\n", i);
            return VSI_FAILURE;
        }
#ifdef __linux__
        gettimeofday( &sigEnd, 0 );
        msVal = 1000 * (sigEnd.tv_sec - sigStart.tv_sec) + (sigEnd.tv_usec - sigStart.tv_usec) / 1000;
        usVal = 1000000 * (sigEnd.tv_sec - sigStart.tv_sec) + (sigEnd.tv_usec - sigStart.tv_usec);
        printf("Run the %u time: %ldms or %ldus\n", (i+1), msVal, usVal);
#endif
        if (msVal > num)
          {
             printf("  Fatal error: process graph time is too long,maybe GPU has hang!!!!!!!!!!!!!!!!\n");
             fp = fopen("error_log.txt","a+");
             fprintf(fp,"  run the %u time,loop not end ! process Graph time is %ld ms.\n",(i+1),msVal);
             fclose(fp);
             exit(1);
          }
        /* Save all output tensor data to txt file */
        vnn_SaveOutputData(graph);
        ctx = oragin("output0_640_640_3.txt");
        for (j=0;j<16;j++)
        {
	  if (cty.buf[j] != ctx.buf[j])
           {
		 printf ("  Fatal error: when toop to %u times,Accurary error!!!!!!!!!!!!!\n",(i+1));
                 fp = fopen("error_log.txt","a+");
                 fprintf(fp,"  Fatal error: when toop %u times,Accurary error\n",(i+1));
                 fclose(fp);
		 exit(1);
	   }
        }
     }


final:
    return status;
}

static vsi_status vnn_PreProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph,
    const char *image_name
    )
{
    return vnn_PreProcessDncnn( graph, image_name );
}

static vsi_nn_graph_t *vnn_CreateNeuralNetwork
    (
    const char *data_file_name
    )
{
    vsi_nn_graph_t *graph = NULL;

    graph = vnn_CreateDncnn(data_file_name, NULL);
    _CHECK_PTR(graph, final);

    /* Show the node and tensor */
    vsi_nn_PrintGraph(graph);

final:
    return graph;
}

/*-------------------------------------------
                  Main Functions
-------------------------------------------*/
int main
    (
    int argc,
    char **argv
    )
{
    vsi_status status;
    vsi_nn_graph_t *graph;
    const char *data_name = NULL;
    const char *image_name = NULL;
    FILE *fp;

    status = VSI_FAILURE;
    if (argc != 3)
    {
        printf("Usage:%s data_file_name image_file_name\n", argv[0]);
        return -1;
    }

    data_name = (const char *)argv[1];
    image_name = (const char *)argv[2];

#ifdef __linux__
    struct timeval tmsStart, tmsEnd;
    long int msVal,usVal;
    gettimeofday( &tmsStart, 0 );
#endif

    /* Create the neural network */
    graph = vnn_CreateNeuralNetwork( data_name );
    _CHECK_PTR(graph, final);

    /* Pre process the image data */
    status = vnn_PreProcessNeuralNetwork( graph, image_name );
    _CHECK_STATUS( status, final );

#ifdef __linux__
    gettimeofday( &tmsEnd, 0 );
    msVal = 1000 * (tmsEnd.tv_sec - tmsStart.tv_sec) + (tmsEnd.tv_usec - tmsStart.tv_usec) / 1000;
    usVal = 1000000 * (tmsEnd.tv_sec - tmsStart.tv_sec) + (tmsEnd.tv_usec - tmsStart.tv_usec);
    printf("creatnetwork time:");
    printf("   %ldms or %ldus\n", msVal, usVal);
#endif

    /* Verify and Process graph */
    status = vnn_ProcessGraph( graph );
    _CHECK_STATUS( status, final );

    if (VNN_APP_DEBUG)
    {
        /* Dump all node outputs */
        vsi_nn_DumpGraphNodeOutputs(graph, "./network_dump", NULL, 0, TRUE, 0);
    }

    /* Post process output data */
    status = vnn_PostProcessNeuralNetwork( graph );
    _CHECK_STATUS( status, final );
if (VSI_FAILURE == status)
   {
      return 1;
   }
else if (VSI_SUCCESS == status)
    {
    printf("  all process is over\n");
    fp = fopen("error_log.txt","a+");
    fprintf(fp,"  Case end successfully.\n\n\n");
    fclose(fp);
    return 0;
    }

final:
    vnn_ReleaseNeuralNetwork( graph );
    return status;
}

