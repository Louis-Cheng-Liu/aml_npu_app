/****************************************************************************
*   Generated by ACUITY 3.8.2
*   Match ovxlib 1.0.3
*
*   Neural Network appliction pre-process source file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "jpeglib.h"

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_pre_process.h"

#define _BASETSD_H
/*-------------------------------------------
                  Functions
-------------------------------------------*/

static vsi_enum vnn_GetFileType(const char *file_name)
{
    vsi_enum type = 0;
    char *ptr;
    char suffix = '.';
    uint32_t pos,n;

    char buff[32] = {0};

    ptr = strrchr(file_name, suffix);
    pos = ptr - file_name;

    n = strlen(file_name) - (pos + 1);
    strncpy(buff, file_name+(pos+1), n);

    if (strcmp(buff, "jpg") == 0
        || strcmp(buff, "jpeg") == 0
        || strcmp(buff, "JPG") == 0
        || strcmp(buff, "JPEG") == 0 )
    {
        type = NN_FILE_JPG;
    }
    else if(strcmp(buff, "tensor") == 0)
    {
        type = NN_FILE_TENSOR;
    }
    else if(strcmp(buff, "qtensor") == 0)
    {
        type = NN_FILE_QTENSOR;
    }
    else
    {
        type = NN_FILE_NONE;
    }

    return type;
}

static int vnn_ConvertJpegToBmpData
    (
    FILE * inputFile,
    unsigned char* bmpData,
    uint32_t *bmpWidth,
    uint32_t *bmpHeight
    )
{
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    JSAMPARRAY buffer;
    unsigned char *point = NULL;
    unsigned long width, height;
    unsigned short depth = 0;

    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo,inputFile);
    jpeg_read_header(&cinfo,TRUE);

    cinfo.dct_method = JDCT_IFAST;

    if (bmpData == NULL)
    {
        width = cinfo.image_width;
        height = cinfo.image_height;
    }
    else
    {
        jpeg_start_decompress(&cinfo);

        width  = cinfo.output_width;
        height = cinfo.output_height;
        depth  = cinfo.output_components;


        buffer = (*cinfo.mem->alloc_sarray)
            ((j_common_ptr)&cinfo, JPOOL_IMAGE, width*depth, 1);

        point = bmpData;

        while (cinfo.output_scanline < height)
        {
            jpeg_read_scanlines(&cinfo, buffer, 1);
            memcpy(point, *buffer, width * depth);
            point += width * depth;
        }

        jpeg_finish_decompress(&cinfo);
    }

    jpeg_destroy_decompress(&cinfo);

    if (bmpWidth != NULL) *bmpWidth = width;
    if (bmpHeight != NULL) *bmpHeight = height;
    return depth;
}

static uint8_t *vnn_ImagedataToDtype
    (
    vsi_nn_tensor_t *tensor,
    uint8_t *data,
    float *mean_value,
    uint32_t width,
    uint32_t height,
    uint32_t channel
    )
{
    vsi_status status = VSI_FAILURE;
    uint32_t   i, j, sz, offset, stride;
    uint8_t *Dbuffer = NULL;

    sz = width * height * channel;
    stride = vsi_nn_TypeGetBytes( tensor->attr.dtype.vx_type );
    Dbuffer = (uint8_t *)malloc(stride * sz * sizeof(uint8_t));
    _CHECK_PTR(Dbuffer, error);
    memset(Dbuffer, 0, stride * sz * sizeof(uint8_t));

    if (mean_value)
    {
        float mean,scale,val;
        scale = mean_value[3];

        for (i = 0; i < channel; i ++)
        {
            mean = mean_value[i];
            offset = width * height * i;
            for (j = 0; j < width * height; j ++)
            {
                val = ((float)data[offset + j] - mean) / scale;
                status = vsi_nn_Float32ToDtype(val, &Dbuffer[stride * (offset + j)], &tensor->attr.dtype);
                _CHECK_STATUS(status, error);
            }
        }
    }
    else
    {
        for (i = 0; i < sz; i ++)
        {
            status = vsi_nn_Float32ToDtype((float)data[i], &Dbuffer[stride * i], &tensor->attr.dtype);
            _CHECK_STATUS(status, error);
        }
    }

    return Dbuffer;
error:
    if (Dbuffer)free(Dbuffer);
    return NULL;
}

/*
    Transpose the RGB888 data for driver
    RGBRGBRGB --> reorder[2 1 0]: BBBGGGRRR --- caffe
    RGBRGBRGB --> reorder[0 1 2]: RRRGGGBBB --- tensorflow
*/
static void vnn_ImagedataTranspose
    (
    uint8_t *bmp_data,
    uint32_t *reorder,
    uint32_t width,
    uint32_t height,
    uint32_t channels
    )
{
    uint32_t   i, j, offset, sz, order;
    uint8_t *data;

    sz = width * height * channels;
    data = (uint8_t *)malloc(sz * sizeof(uint8_t));
    if (data == NULL) return ;
    memset(data, 0, sizeof(uint8_t) * sz);

    for (i = 0; i < channels; i ++)
    {
        if (reorder && channels > 1)
        {
            order = reorder[i];
        }
        else
        {
            order = i;
        }

        offset = width * height * i;

        for (j = 0; j < width * height; j ++)
        {
            data[j + offset] = bmp_data[j * channels + order];
        }
    }

    memcpy(bmp_data, data, sz * sizeof(uint8_t));
    if (data)free(data);
}

/*
    jpg file --> BMP data(dataformat: RGBRGBRGB...)
*/
static uint8_t *vnn_ReadJpegImage
    (
    const char *name,
    uint32_t width,
    uint32_t height,
    uint32_t channels
    )
{
    uint8_t   *bmpData;
    uint32_t   sz;
    FILE *bmpFile;

    bmpData = NULL;
    bmpFile = NULL;
    sz = width * height * channels;

    bmpFile = fopen( name, "rb" );
    _CHECK_PTR(bmpFile, final);

    bmpData = (uint8_t *)malloc( sz * sizeof( uint8_t ) );
    _CHECK_PTR(bmpData, final);
    memset(bmpData, 0, sizeof( uint8_t ) * sz);

    vnn_ConvertJpegToBmpData( bmpFile, bmpData, NULL, NULL );

final:
    if (bmpFile)fclose(bmpFile);
    return bmpData;
}

static vx_dtype *vnn_ReadQTensorImage
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    uint32_t i = 0;
    float fval = 0.0;
    vx_dtype *tensorData;
    uint32_t sz = 1;
    FILE *tensorFile;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    _CHECK_PTR(tensorFile, error);

    for (i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }

    tensorData = (vx_dtype *)malloc(sz * sizeof(vx_dtype));
    _CHECK_PTR(tensorData, error);
    memset(tensorData, 0, sz * sizeof(vx_dtype));

    for (i = 0; i < sz; i++)
    {
        if (fscanf( tensorFile, "%f ", &fval ) != 1)
        {
            printf("Read tensor file fail\n");
            goto error;
        }
        tensorData[i] = (vx_dtype)fval;
    }

    if (tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if (tensorFile)fclose(tensorFile);
    return NULL;
}

static uint8_t *vnn_ReadTensorImage
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    vsi_status status = VSI_FAILURE;
    uint32_t i = 0;
    float fval = 0.0;
    uint8_t *tensorData;
    uint32_t sz = 1;
    uint32_t stride = 1;
    FILE *tensorFile;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    _CHECK_PTR(tensorFile, error);

    for (i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }

    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    tensorData = (uint8_t *)malloc(stride * sz * sizeof(uint8_t));
    _CHECK_PTR(tensorData, error);
    memset(tensorData, 0, stride * sz * sizeof(uint8_t));

    for (i = 0; i < sz; i++)
    {
        if (fscanf( tensorFile, "%f ", &fval ) != 1)
        {
            printf("Read tensor file fail\n");
            goto error;
        }
        status = vsi_nn_Float32ToDtype(fval, &tensorData[stride * i], &tensor->attr.dtype);
        _CHECK_STATUS(status, error);
    }

    if (tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if (tensorFile)fclose(tensorFile);
    return NULL;
}

vsi_status vnn_PreProcessDncnn
    (
    vsi_nn_graph_t *graph,
    const char *image_name
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_enum fileType;
    vsi_nn_tensor_t *tensor;
    uint8_t *data = NULL;
    uint8_t *bmpData = NULL;
    float mean_value[4] = {0.0,0.0,0.0,255.0};
    uint32_t *reorder = NULL;

    tensor = vsi_nn_GetTensor( graph, graph->input.tensors[0] );
    fileType = vnn_GetFileType(image_name);
    if (fileType == NN_FILE_JPG)
    {
        uint32_t width     = tensor->attr.size[0];
        uint32_t height    = tensor->attr.size[1];
        uint32_t channel   = tensor->attr.size[2];
        bmpData = vnn_ReadJpegImage(image_name, width, height, channel);
        _CHECK_PTR(bmpData, final);

        /* image data transpose */
        vnn_ImagedataTranspose(bmpData, reorder, width, height, channel);

        /* handle mean-value and convert data to Dtype */
        data = vnn_ImagedataToDtype(tensor, bmpData, mean_value, width, height, channel);
        _CHECK_PTR(data, final);
    }
    else if (fileType == NN_FILE_TENSOR)
    {
        data = vnn_ReadTensorImage(tensor, image_name);
        _CHECK_PTR(data, final);
    }
    else if (fileType == NN_FILE_QTENSOR)
    {
        data = (uint8_t *)vnn_ReadQTensorImage(tensor, image_name);
        _CHECK_PTR(data, final);
    }
    else
    {
        printf("This Neural Network Only support tensor file or JPG image file\n");
        status = VSI_FAILURE;
        _CHECK_STATUS(status, final);
    }

    /* Copy the Pre-processed data to input tensor */
    status = vsi_nn_CopyDataToTensor(graph, tensor, data);
    _CHECK_STATUS(status, final);

    /* Save the image data to txt */
    if (fileType == NN_FILE_QTENSOR)
    {
        vsi_nn_SaveTensorToText( graph, tensor, "input.txt", NULL );
    }
    else
    {
        vsi_nn_SaveTensorToTextByFp32( graph, tensor, "input.txt", NULL );
    }

final:
    if (bmpData)free(bmpData);
    if (data)free(data);
    return status;
}
